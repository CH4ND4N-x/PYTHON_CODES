# How the memory is allocated in C Language 
# Use of & addressof operator to find the address
# int a = 6 ;
# &a

# How the memory is allocated in Python Language 
a = 6
print(id(a))  # 4491355520


# Introduce the concept of Reference Count
b = 6
print(id(b)) 
print(id(a))


# Everything in Python is class
a = 6
#a = 10.7
#a = "Forsk"
#a = True
#a = None

print(type(a))
print(a.__class__)

# If primary data types are class then we can create objects
b = int()
print(b)
print(type(b))


c = int(7)
print(c)
print(type(c))

# Summary
# datatype = you create a variable of it
# Class    = you create a object of it and 
#            store address in reference variable
# Difference between Reference Variable and Object







# OOPS is Object Oriented Programming System
# OOD  is Object Oriented Design

# Introducing the keywords of Object Oriented Programming
"""
Class
Object/Instance
Reference Variable
Data Hiding   
    Abstraction     - Something only existing as an idea
    Encapsulation   - Restricts access 
    Inheritance     - Create a new from existing
    Polymorphism    - Object that have more than 1 form 
Overriding 
Overloading
"""

# Introduce the concept of Lamp

"""
# Steps for converting a REAL LIFE OBJECT into a CLASS
# 1. Visualise the REAL LIFE OBJECT in your memory 
# 2. List down the characteristics/state of the object
# 3. List down the Functionality/Behaviour of the object 
# 4. Class name will be or should be same as the REAL WORLD OBJECT
# 5. All the characteristics is mapped into variable/fields
# 6. All functionalities are mapped into function/methods

Characteristics/State is either ON or OFF 
Which can be interpreted when it is giving LIGHT

Functionality/Behaviour is to switch ON or switch OFF

Class is a blueprint for creating instances (objects)


Class
    Lamp

Field
    isOn  

Methods
    turnOn()
    turnOff()

"""
  

# Introduce the concept of Radio Blueprint 
"""
Characteristics    |   Functionality
state              |   Behaviour
---------------------------------------
color              |
brand              |
ACPower            |
headphone          |
                   |
power_led          | power_switch  ( ON / OFF)
mode_led           | mode_switch   ( AM / FM )
frequency          | band_tuner    ( 88 - 108 )
volume             | volume_tuner  ( 1 - 10 )
---------------------------------------
Characteristics/State are mapped into data/field
Functionality/Bahaviour are mapped into functions/methods
Class is a blueprint for creating instances (objects)
"""

# Introduce the concept of Employee
"""     
Individual employee will have specific attributes and methods
Name
email address
Pay

Each individual employee would be the instance of the class 
"""

class Employee:
    pass

emp_1 = Employee()
emp_2 = Employee()


print ( emp_1)     # 0x115b68b00
print ( id(emp_1)) # 4659251968

print ( emp_2)
print ( id(emp_2))


"""
             Instance
              /    \
             /      \
            /        \
     variables      methods


              Class
              /    \
             /      \
            /        \
     variables      methods

"""
class Employee:
    def __init__(self, first, last, pay):
        print("Init is called")
        self.first = first
        self.last = last
        self.pay = pay 
        self.email=first.lower() + "." + last.lower() + "@gmail.com"
        # declaring simple variables within this method will have limited scope

emp_1 = Employee("Sylvester","Fernandes",50000)
emp_2 = Employee("Yogendra","Singh",60000)

print(id(emp_1))
print(id(emp_2))

print(emp_1.email)
print(emp_2.email)


# Adding Action (Methods) to the class using functions 
# Display Full Name of the employee 
# create method in the class

class Employee:
    def __init__(self, first, last, pay):
        self.first = first
        self.last = last
        self.pay = pay 
        self.email=first.lower() + "." + last.lower() + "@gmail.com"

    def fullname(self):
        return "{} {}".format(self.first,self.last) 

emp_1 = Employee("Sylvester","Fernandes",50000)
emp_2 = Employee("Yogendra","Singh",60000)


print ( emp_1.fullname() )
print ( emp_2.fullname() )

# calling the methods from the class name, 
# but we need to pass the instance
# thats why the self object is passed

print (Employee.fullname(emp_1))
print (Employee.fullname(emp_2))


# Class Variables
class Employee:
    # declare this in the class level 
    num_of_emps = 0

    def __init__(self, first, last, pay):
        self.first = first
        self.last = last
        self.pay = pay 
        self.email=first.lower() + "." + last.lower() + "@gmail.com"
        # we need to increase the value in the init method
        Employee.num_of_emps += 1
    
    def fullname(self):
        return "{} {}".format(self.first,self.last) 


emp_1 = Employee("Sylvester","Fernandes",50000)
emp_2 = Employee("Yogendra","Singh",60000)

# How can we access the class variables using the self object 
print (Employee.num_of_emps )
print (emp_1.num_of_emps )
print (emp_2.num_of_emps )



# Inheritance - Creating Subclasses
# Super Class or Parent Class or Base Class
# Sub Class or Child Class or Derived Class    

class Developer( Employee ) :
    pass

print(issubclass(Developer,Employee))

dev_1 = Developer ("Sylvester", "Fernandes",50000)
dev_2 = Developer ("Yogendra", "Singh",60000)

print ( dev_1.email )
print ( dev_2.email )

print(isinstance(dev_1,Developer))
print(isinstance(dev_1,Employee))


# This gives a clear picture of the inheritance and the variables 
# Method resolution order
print ( help( Developer ) ) 



# Overriding variables in subclass 
# Similarly methods can also be overided 
# Creating the initialize 

class Developer( Employee ) :
    raise_amount = 1.10
    def __init__(self, first, last, pay, prog_lang ):
        super().__init__(first, last,pay)
        self.prog_lang = prog_lang  


# this will only affect the instances of the Developer class and not Employee class 

dev_1 = Developer ("Sylvester", "Fernandes",50000,"Python")
dev_2 = Developer ("Yogendra", "Singh",60000,"Java")


print ( dev_1.email )
print ( dev_1.prog_lang )


# Multiple Inheritance

class A:
    pass

class B:
    pass

class C ( A, B):
    pass


# Multi Level Inheritance

class D:
    pass

class E(D):
    pass

class F(E):
    pass


# Python does not have access modifiers. ( Private Public Protected )
# All members in a Python class are public by default.
# If you want to access an instance (or class) variable from outside the instance or class, 
# you are always allowed to do so. 
# The single underscore prefix for a member variable or 
# method is a commonly used convention to denote a protected method.
# The double underscore prefix for a member variable or 
# method is a commonly used convention to denote a private method.

"""
variable        public 
_variable_      protected
__variable__    private     
"""